#__ПОЛИМОРФИЗМ__#

# В Python всё является объектами,
# потому многие операции являются полиморфическими.
# В зависимости от типа объекта будет определяться 
# поведение оператора или метода

def foo(x):
    return x * 2

a = foo(1) * foo("2")
b = foo(3.) * foo(foo(4))
print(a) # Для строк оператор умножения читается как повторение
print(b) # Для чисел - как обычное умножение

# Два класса могут иметь одинаковый метод,
# но этот метод будет выполнять разные операции
# в зависимости от того, к объекту какого класса
# он применяется 
class A():
    a = 5
    def result(self, numb):
        self.result = int(self.a) + int(numb)
        # В классе А() метод result() возвращает
        # сумму двух чисел
        
class B(): 
    def result(self, s):
        self.result = len(str(s))
        # В классе В() метод result возвращает 
        # длину строки
        
obj_1 = A() # Создаём объекты каждого класса
obj_2 = B()
obj_1.result(12) # Применяем метод result()
obj_2.result(12) # к каждому из них
print(obj_1.result) # Получаем сумму
print(obj_2.result) # Получаем длину строки

#_______________________________#

# Также можно переопределить стандартные методы 
# базовых классов
# Например, метод __add__ и __str__

class Add():
    def __init__(self, var_1):
        self.a = var_1
        
    def __add__(self, var_2):
        self.sum = var_2 + self.a
        return self.sum 
        # Сохраним результат в данную функцию
        
    def __str__(self): 	
        return('Результат: ' + str(self.sum)) 
        # Превратим результат из числового 
        # в строковый и сохраним в данной функции,
        # которая автоматически вызывается, когда 	 
        # к объекту применяется print()
                        
obj_1 = Add(10) 
obj_2 = Add(2) 
obj_1.__add__(obj_2) # Срабатывает, потому что мы вызвали данный метод
                     # и применили к объекту obj_1.   

print(obj_1) # Здесь у нас вызывается obj_1.__str__(self), в котором 		 
             # сохранён рузультат нашей суммы.